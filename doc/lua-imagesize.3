.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUA-IMAGESIZE 3"
.TH LUA-IMAGESIZE 3 "2012-09-08" "1.2" "Lua module for getting image sizes"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Lua-ImageSize \- Lua 5.1 module for getting the size of bitmap image files
.SH "Description"
.IX Header "Description"
This module can tell you the size in pixels of bitmap images in various
formats, as well as what file format they are in.  It's a small module
which only knows how to extract the size information from image files,
not a full graphics library.  It is written in pure Lua, so doesn't require
any compilation, and it doesn't depend on any other Lua modules.
.SH "Loading the module"
.IX Header "Loading the module"
The ImageSize module doesn't install itself into any global tables, so you can
decide what name you want to use to access it.  You will probably want to
load it like this:
.PP
.Vb 1
\&    local ImageSize = require "imagesize"
.Ve
.PP
You can use a variable called something other than \f(CW\*(C`ImageSize\*(C'\fR if you'd like,
or you could assign the table returned by \f(CW\*(C`require\*(C'\fR to a global variable.
In this documentation we'll assume you're using a variable called \f(CW\*(C`ImageSize\*(C'\fR.
.SH "Finding the size of an image"
.IX Header "Finding the size of an image"
To get the size and type of an image stored in a file on disk:
.PP
.Vb 1
\&    local width, height, format = ImageSize.imgsize(filename)
.Ve
.PP
The width and height will be integer numbers, and the format will be
a string containing a \s-1MIME\s0 type (often an unofficial one like
\&\f(CW\*(C`image/x\-xpixmap\*(C'\fR).
.PP
If the file can't be read, is in an unrecognized format, or is corrupted,
then the width and height will be nil, and the format will be replaced by
an error message.  If you want to detect errors, use this idiom:
.PP
.Vb 2
\&    local width, height, format = ImageSize.imgsize(filename)
\&    assert(width, "error getting size of image: " .. format)
.Ve
.PP
Instead of a filename you can also pass an open file handle in to the
\&\f(CW\*(C`imgsize\*(C'\fR function.  It must support seeking.  It's current position
will be restored before the function returns.
.PP
You can also get the size of an image file stored in a string, using
the alternative function \f(CW\*(C`imgsize_string\*(C'\fR, like this:
.PP
.Vb 3
\&    local file = assert(io.open(filename, "rb"))
\&    local data = file:read("*a")
\&    file:close()
\&
\&    local width, height, format = ImageSize.imgsize_string(data)
.Ve
.SH "Functions"
.IX Header "Functions"
The table returned from \f(CW\*(C`require "imagesize"\*(C'\fR will contain the following
functions:
.IP "imgsize(file, [options])" 4
.IX Item "imgsize(file, [options])"
Reads data from \f(CW\*(C`file\*(C'\fR (either a string containing a filename, or a
Lua file handle), and if possible returns three values, the width, height,
and \s-1MIME\s0 type of the image.  If there is any kind of error then the three
values returned will be nil, nil, and a string describing the error.
.Sp
If \f(CW\*(C`options\*(C'\fR is present it must be a table of values to tune how certain
file formats are treated.  The options available are documented in the
section 'File formats' below.  If an option has an invalid value then
an error will be raised (this being the only kind of error which will
be returned as an exception rather than with return values).
.Sp
The \f(CW\*(C`file\*(C'\fR argument can also be a file handle created by the
\&\fIlua\-memoryfile\fR\|(3) module.
.IP "imgsize_string(str, [options])" 4
.IX Item "imgsize_string(str, [options])"
This behaves identically to \f(CW\*(C`imgsize\*(C'\fR, except that the binary data in the
string \f(CW\*(C`str\*(C'\fR is examined instead of the content of a file.
.SH "File formats"
.IX Header "File formats"
The following file formats are supported, and return the specified \s-1MIME\s0
type:
.IP "\s-1BMP\s0" 4
.IX Item "BMP"
Windows bitmap images, \f(CW\*(C`image/x\-ms\-bmp\*(C'\fR
.IP "\s-1GIF\s0" 4
.IX Item "GIF"
GIF87a and GIF89a images or animations, \f(CW\*(C`image/gif\*(C'\fR
.Sp
Accepts the option \f(CW\*(C`gif_behavior\*(C'\fR (note the non-British spelling), which can
take any of the following strings as its value:
.RS 4
.IP "screen" 4
.IX Item "screen"
Returns the size of the whole image, which should be large enough to
accommodate all the frames of the animation.
.IP "first" 4
.IX Item "first"
Returns the size of the first frame, which may be smaller than the display
size of the whole animation.
.IP "largest" 4
.IX Item "largest"
Returns the size of the largest frame in the animation.
.RE
.RS 4
.Sp
The default value is \f(CW\*(C`screen\*(C'\fR.
.RE
.IP "\s-1JPEG\s0" 4
.IX Item "JPEG"
\&\s-1JFIF\s0 \s-1JPEG\s0 images, \f(CW\*(C`image/jpeg\*(C'\fR
.IP "\s-1MNG\s0" 4
.IX Item "MNG"
\&\s-1MNG\s0 animations, \f(CW\*(C`video/x\-mng\*(C'\fR
.IP "\s-1PCD\s0" 4
.IX Item "PCD"
Kodak Photo \s-1CD\s0 images, \f(CW\*(C`image/x\-kodak\-photocd\*(C'\fR
.Sp
Note that the code for this hasn't been tested since it was ported from
Perl, because I can't find any \s-1PCD\s0 images anywhere to test against.
.Sp
The option \f(CW\*(C`pcd_scale\*(C'\fR can be used to select the scale at which the
image should be decompressed.  It seems that \s-1PCD\s0 images don't have a single
intrinsic size, or perhaps have several, so there's no one right answer
to this.  The acceptable values for this option are:
.RS 4
.IP "\(bu" 4
base/16
.IP "\(bu" 4
base/4
.IP "\(bu" 4
base
.IP "\(bu" 4
base4
.IP "\(bu" 4
base16
.IP "\(bu" 4
base64
.RE
.RS 4
.Sp
The default value is \f(CW\*(C`base\*(C'\fR.
.RE
.IP "\s-1PNG\s0" 4
.IX Item "PNG"
\&\s-1PNG\s0 images, \f(CW\*(C`image/png\*(C'\fR
.IP "\s-1PNM\s0" 4
.IX Item "PNM"
Any of the 'portable anymap' formats: \s-1PPM\s0 (\f(CW\*(C`image/x\-portable\-pixmap\*(C'\fR),
\&\s-1PGM\s0 (\f(CW\*(C`image/x\-portable\-graymap\*(C'\fR), or \s-1PBM\s0 (\f(CW\*(C`image/x\-portable\-bitmap\*(C'\fR).
Also supported are the thumbnail files generated by \s-1XV\s0
(\f(CW\*(C`image/x\-xv\-thumbnail\*(C'\fR, a \s-1MIME\s0 type I invented for this purpose).
.IP "\s-1PSD\s0" 4
.IX Item "PSD"
Photoshop images, \f(CW\*(C`image/x\-photoshop\*(C'\fR
.IP "Flash" 4
.IX Item "Flash"
Macromedia Flash animations (\s-1SWF\s0 files), \f(CW\*(C`application/x\-shockwave\-flash\*(C'\fR
.Sp
Note that currently compressed \s-1SWF\s0 files are not supported (one which begins
with the letters \f(CW\*(C`CWS\*(C'\fR rather than \f(CW\*(C`FWS\*(C'\fR).
.IP "\s-1TIFF\s0" 4
.IX Item "TIFF"
\&\s-1TIFF/TIF\s0 images, \f(CW\*(C`image/tiff\*(C'\fR
.IP "\s-1XBM\s0" 4
.IX Item "XBM"
X Bitmap images, \f(CW\*(C`image/x\-xbitmap\*(C'\fR
.IP "\s-1XCF\s0" 4
.IX Item "XCF"
\&\s-1XCF\s0 images, usually used for saving a work-in-progress in The Gimp,
\&\f(CW\*(C`application/x\-xcf\*(C'\fR
.Sp
Note that currently these are only recognized when not compressed.
.IP "\s-1XPM\s0" 4
.IX Item "XPM"
X Pixmap images, \f(CW\*(C`image/x\-xpixmap\*(C'\fR
.SH "Copyright"
.IX Header "Copyright"
Copying and distribution are permitted under the terms of the Artistic
License 2.0 (http://www.opensource.org/licenses/artistic\-license\-2.0.php <http://www.opensource.org/licenses/artistic-license-2.0.php>) or
the \s-1GNU\s0 \s-1LGPL\s0 (http://www.opensource.org/licenses/lgpl\-license.php <http://www.opensource.org/licenses/lgpl-license.php>).
.PP
This Lua module was ported from the Perl Image::Size module by
Geoff Richards.  The Lua port and documentation is Copyright (c) 2008
Geoff Richards <geoff@geoffrichards.co.uk>.
.PP
The original Perl module was written by Randy J. Ray
<rjray@blackperl.com>, based on image-sizing code by Alex Knowles
<alex@ed.ac.uk> and Andrew Tong <werdna@ugcs.caltech.edu>,
used with their joint permission.
.PP
Many bug fixes and patches were provided by other people.  See the
documentation for the Image::Size Perl module for details.
